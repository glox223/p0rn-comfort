#!/usr/bin/perl -w
# $Id: p0rn-bot,v 1.15 2005-10-30 13:30:57 mitch Exp $
#
# automatically register pages with p0rn-proxy
#
# 2004 (C) by Christian Garbs <mitch@cgarbs.de>
# Licensed under GNU GPL.  See COPYING for details.

use strict;
use AppConfig qw(:expand);
use HTML::Parser;
use LWP::UserAgent;
use URI;
use P0rn::DB;
use P0rn::Static;

=head1 NAME

p0rn-bot - register pages with p0rn-proxy automatically

=head1 SYNOPSIS

B<p0rn-bot>

S<[ B<--depth> I<depth> ]>
S<[ B<--help> ]>
S<[ B<--proxy> I<proxy> ]>
S<[ B<--version> ]>

B<p0rn-proxy>
S<[ B<-c> I<configfile> ]>
S<[ B<-h> ]>
S<[ B<-P> I<proxy> ]>
S<[ B<-V> ]>

=head1 OVERVIEW

p0rn-bot is a script that automates p0rn-proxy handling.  It starts
with a given page and then follows all links recursivly.  All pages
encountered are registered with p0rn-proxy either as thumnails sites
or as galleries for download.

=head1 DESCRIPTION

Be sure to have L<p0rn-proxy(1)> running.  Then start B<p0rn-bot> with
the URL of a known thumbnail gallery page.  Now wait and see p0rn-bot
do it's work.

When p0rn-bot is finished, the pages are marked for download.  Run
L<p0rn-download(1)> to actually get them.

=head2 Switches

=over 5

=item B<--depth> I<depth> | B<-d> I<depth>

This sets how 'deep' links are being followed.  0 will only look at
the given start URL, 1 will visit the start URL plus all sites that
are linked on it and so forth...

Default depth is 2.

=item B<--help> | B<-h>

This prints a short help text and exits.

=item B<--proxy> I<proxy> | B<-P> I<proxy>

This gives the address where the p0rn-proxy is running.  It is given
in the form 'http://hostname:portnumber'.

Default is to use 'http://localhost:8080' as this is the default port
that p0rn-proxy listens to.

=item B<--version> | B<-V>

This prints the current version of japana and exits.

=back

=head1 SEE ALSO

L<p0rn-proxy(1)>

=head1 MODULES NEEDED

 use AppConfig;
 use HTML::Parser;
 use HTTP::Daemon;
 use LWP::UserAgent;
 use URI;

These modules can be obtained from L<http://www.cpan.org>.

=head1 BUGS

Please report bugs by mail to <F<p0rn-bugs@cgarbs.de>>.

=head1 AUTHOR

p0rn-bot was written by Christian Garbs <F<mitch@cgarbs.de>>.

=head1 AVAILABILITY

Look for updates at L<http://www.cgarbs.de/p0rn-comfort.en.html>.

=head1 COPYRIGHT

p0rn-bot is licensed under the GNU GPL.

=cut

######[ Global Variables ]
#

my $CVSVERSION = do { my @r = (q$Revision: 1.15 $ =~ /\d+/g); sprintf "%d."."%02d" x $#r, @r };
my ($status, $base, $ua, $parser);
my @pics;
my @pages;
my @todo;
my ($count_pic, $count_thumb, $count_empty) = (0, 0, 0);
my $dbh;

######[ Subroutines ]
#

sub debug(@)
# print debugging message
{
    warn "@_\n";
}

sub mark_for_download($)
# add link to download list
{
    seturi($dbh, shift, 1, 2);
}

sub mark_as_processed_thumbnail($)
# add link to thumbnail list
{
    seturi($dbh, shift, 2, 4);
}

sub start_handler
# callback for HTML::Parser to react on link tags
{
    return unless shift eq "a";
    my $attr = shift;
    my $link = $attr->{href};

    return unless defined $link;
    $link =~ s/\#.*$//;
    return if $link eq $base;
    return if $link =~ m,^$Static::PROXY_CTRL_BASE,;
    return if $link =~ /^(mailto|ed2k|ftp|news|telnet|javascript):/i;
    return if $link =~ /^\s*$/;
    
    $link = URI->new_abs($link, $base)->as_string;

    if ($link =~ /\.(jpe?g|wmv|mpe?g|avi)$/i) {
	push @pics, $link;
    } else {
	push @pages, $link;
    }
}

sub parse_page($$)
# parse an HTML page
{
    my ($response, $urls) = (@_);
    
    $base = $response->base;
    @pics = ();
    @pages = ();
    $parser->parse($response->content);

    $status .= $base . ' ' . ${Static::BLUE} . @pics . '/' . @pages . ' ';

    if (@pics + @pages > 0) {
	if (@pics > @pages) {
	    $status .= ${Static::GREEN}.'PICTURE';
	    mark_for_download($base);
	    $count_pic++;
	} else {
	    $status .= ${Static::YELLOW}.'thumbnail';
	    mark_as_processed_thumbnail($base);
	    push @{$urls}, (@pages);
	    $count_thumb++;
	}
    } else {
	$status .= ${Static::CYAN}."empty";
	$count_empty++;
    }
    $status .= ${Static::NORMAL};
}

sub check_url($)
# fetch an HTML page and process it
{
    my $url = shift;
    my @urls;

    return unless defined $url;
    
    # mark as 'in progress'
    seturi($dbh, $url, -1, 3);

    $status="";

    my $response = $ua->get($url);
    
    if ($response->is_success) {

        # check for redirects
        if ($response->base ne $url) {
            @urls = $response->base;
            $status .= "$url ${Static::VIOLET}redirect${Static::NORMAL}";
        } else {
            parse_page( $response, \@urls );
        }
    } else {
	$status .= "$url ${Static::CYAN}failed " . $response->code . ${Static::NORMAL};
	# mark as finished
	seturi($dbh, $url, -1, 4);
    }
    
    debug $status;

    # dedupe
    my %urls = map { $_ => 0 } @urls;
    foreach $url (keys %urls) {
	# is it already listed?
	my $ref = geturi($dbh, $url);
	if (not exists $ref->{url}) {
	    # new entry type "unkown"
	    inserturi($dbh, $url, 3, 2, 0);
	}
    }

}

sub print_usage()
# prints a short help text and exits
{
    print << "EOF";

Usage: p0rn-bot [options] start_url
Supported options (long and short forms):
  -d, --depth         : set link recursion depth
  -h, --help          : print usage and exit
  -P, --proxy         : set proxy to use
  -v, --version       : print version number and exit
EOF
;
    exit 0;
}

######[ Main program ]
#
   
print "this is p0rn-bot ${Static::VERSION}/${CVSVERSION}\n";

# define configuration options
my $config = AppConfig->new( { CASE => 1 } );
$config->define( 'depth|d=s',         { DEFAULT => '2' } );
$config->define( 'proxy|P=s',         { DEFAULT => $ENV{'HTTP_PROXY'}, EXPAND => EXPAND_ENV } );
$config->define( 'version|V!' );
$config->define( 'help|h!' );

# override configuration with command line arguments
$config->getopt( qw(no_ignore_case), [ @ARGV ] );

# if we are to just print the version number, then quit now
exit if $config->version();
		 
# if we are to just print help, then do it now
print_usage() if $config->help();

# create UserAgent
$ua = LWP::UserAgent->new;
$ua->agent("p0rn-bot ${Static::VERSION}/${CVSVERSION}");
$ua->timeout(10);
if ( defined $config->proxy()
     and $config->proxy() ne ""
     and $config->proxy() ne "none" ) {
    print "- using existing proxy on ".$config->proxy()."\n";
    $ua->proxy('http', $config->proxy());
}


# open database
$dbh = opendb();

# create HTML Parser
$parser = HTML::Parser->new(api_version => 3);
$parser->handler( start => \&start_handler, "tagname,attr");

my $count = 0;

my @sorts = (
	     'ORDER BY length(url) ASC LIMIT 1',
	     'AND length(url) < 100 ORDER BY length(url) DESC LIMIT 1',
	     'ORDER BY url ASC LIMIT 1',
	     'ORDER BY url DESC LIMIT 1',
	     'ORDER BY added ASC LIMIT 1',
	     'ORDER BY added DESC LIMIT 1'
	     );

# endless loop!  yahoo!
while (1) {
    $count ++;

    # find random unkown site
    my $ref = $dbh->selectrow_hashref('SELECT url FROM URLs WHERE type = 3 AND status = 2 '. $sorts[$count % @sorts]);
    
    if (! exists $ref->{url}) {
	# none found? try a known thumbnail site instead
	$ref = $dbh->selectrow_hashref('SELECT url FROM URLs WHERE type = 2 AND status = 1 '. $sorts[$count % @sorts]);
    } else {
    }
    last unless exists $ref->{url};

    # work on it
    check_url($ref->{url});

    unless ($count % 50) {
	$dbh->disconnect();
	print "${Static::RED}($count done: pic/thumb/empty = ${count_pic}/${count_thumb}/${count_empty})${Static::NORMAL}\n";
	$dbh=opendb();
    }
}

print "finished.  pic/thumb/empty: ${count_pic}/${count_thumb}/${count_empty}\n";
print "no more pages to crawl.  feed me!\n";
